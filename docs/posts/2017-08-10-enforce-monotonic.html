<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Type Level Memes - Enforce lists to be monotonic at compile time</title>
        <link href="https://fonts.googleapis.com/css?family=Saira" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Type Level Memes</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Enforce lists to be monotonic at compile time</h1>

            <div class="info">
    Posted on August 10, 2017
    
</div>

<p>I’ve been learning lately about type-level programming in haskell and now that I feel that some ideas have <em>clicked</em> it’s time to write down some potential applications. You’re probably not going to need this in particular, but I wanted to show up to what extent the type-system can enforce properties of your program that you wouldn’t even dream of in other languages.</p>
<p>In this post I’ll show you briefly how we can enforce monotonic behaviour in fixed constant lists defined at compile time. As I said, I’ll use some common type-level programming tricks for achieving this goal.</p>
<h2 id="type-level-nats">Type-level nats</h2>
<p>These are the usual Peano naturals:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span>

<span class="ot">zero ::</span> <span class="dt">Nat</span>
zero <span class="fu">=</span> <span class="dt">Z</span>

<span class="ot">one ::</span> <span class="dt">Nat</span>
one <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Z</span>

<span class="ot">two ::</span> <span class="dt">Nat</span>
two <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">One</span></code></pre></div>
<p>Using the <a href="https://downloads.haskell.org/~ghc/7.8.4/docs/html/users_guide/promotion.html"><code>DataKinds</code></a> language extension we can promote those values to types, and the <code>Nat</code> type to a kind. That would allow us to have types like these:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Zero</span> <span class="fu">=</span> <span class="dt">Z</span>
<span class="kw">type</span> <span class="dt">One</span> <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Z</span>
<span class="kw">type</span> <span class="dt">Two</span> <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">One</span></code></pre></div>
<h2 id="type-level-functions">Type-level functions</h2>
<p>The same way we can define the usual sum and order for values of type <code>Nat</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
sum <span class="dt">Z</span> a <span class="fu">=</span> a
sum (<span class="dt">Succ</span> a) b <span class="fu">=</span> <span class="dt">Succ</span> (sum a b)

<span class="ot">lessThanOrEqualTo ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Bool</span>
lessThanOrEqualTo <span class="dt">Z</span> a <span class="fu">=</span> <span class="dt">True</span>
lessThanOrEqualTo a <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">False</span>
lessThanOrEqualTo (<span class="dt">Succ</span> n) (<span class="dt">Succ</span> m) <span class="fu">=</span> lessThanOrEqualTo n m</code></pre></div>
<p>we can make functions that operate on the type level using the <a href="https://kseo.github.io/posts/2017-01-16-type-level-functions-using-closed-type-families.html"><code>TypeFamilies</code></a> language extension:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Sum</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) (<span class="ot">b ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
    <span class="dt">Sum</span> <span class="dt">Z</span> a <span class="fu">=</span> a
    <span class="dt">Sum</span> (<span class="dt">Succ</span> a) b <span class="fu">=</span> <span class="dt">Succ</span> (<span class="dt">Sum</span> a b)

<span class="kw">type</span> familiy <span class="dt">LessThanOrEqualTo</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) (<span class="ot">b ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span>
  <span class="dt">LessThanOrEqualTo</span> <span class="dt">Z</span> b <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">LessThanOrEqualTo</span> a <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">False</span>
  <span class="dt">LessThanOrEqualTo</span> (<span class="dt">Succ</span> n) (<span class="dt">Succ</span> m) <span class="fu">=</span> <span class="dt">LessThanOrEqualTo</span> n m</code></pre></div>
<p>Note that in this example <code>Bool</code> is the kind <code>Bool</code> (thanks to <code>DataKinds</code>) and <code>True</code> and <code>False</code> are both types of kind <code>Bool</code>.</p>
<p>With those type families we could have things like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Proxy</span> a <span class="fu">=</span> <span class="dt">Proxy</span> <span class="co">-- Data.Proxy</span>

<span class="ot">proof ::</span> <span class="dt">Proxy</span> <span class="dt">True</span>
proof <span class="fu">=</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">LessThan</span> <span class="dt">One</span> <span class="dt">Two</span>)) <span class="co">-- compiles</span>

<span class="ot">fakeProof ::</span> <span class="dt">Proxy</span> <span class="dt">True</span>
fakeProof <span class="fu">=</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">LessThan</span> <span class="dt">Two</span> <span class="dt">One</span>)) <span class="co">-- compile time error</span></code></pre></div>
<p>What’s more, using the <a href="https://ocharles.org.uk/blog/posts/2014-12-08-type-operators.html"><code>TypeOperators</code></a> language extension we can change the above type families to:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family (<span class="ot">a ::</span> <span class="dt">Nat</span>) <span class="fu">+</span> (<span class="ot">b ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
    <span class="dt">Z</span> <span class="fu">+</span> a <span class="fu">=</span> a
    <span class="dt">Succ</span> a <span class="fu">+</span> b <span class="fu">=</span> <span class="dt">Succ</span> (a <span class="fu">+</span>  b)

<span class="kw">type</span> familiy (<span class="ot">a ::</span> <span class="dt">Nat</span>) <span class="fu">&lt;=</span> (<span class="ot">b ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span>
  <span class="dt">Z</span> <span class="fu">&lt;=</span> b <span class="fu">=</span> <span class="dt">True</span>
  a <span class="fu">&lt;=</span> <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">False</span>
  (<span class="dt">Succ</span> n) <span class="fu">&lt;=</span> (<span class="dt">Succ</span> m) <span class="fu">=</span> n <span class="fu">&lt;=</span> m

<span class="ot">proof ::</span> <span class="dt">Proxy</span> <span class="dt">True</span>
proof <span class="fu">=</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">One</span> <span class="fu">&lt;=</span> <span class="dt">True</span>))</code></pre></div>
<h2 id="turn-type-level-naturals-into-values">Turn type-level naturals into values</h2>
<p>We want a function that turns any type of kind <code>Nat</code> into an integer. You can’t have a function from a type to a value in haskell but we can model that with the <code>Proxy</code> type-constructor.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ToInt</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) <span class="kw">where</span>
<span class="ot">    toInt ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>

<span class="kw">instance</span> <span class="dt">ToInt</span> <span class="dt">Z</span> <span class="kw">where</span>
    toInt _ <span class="fu">=</span> <span class="dv">0</span>

<span class="kw">instance</span> <span class="dt">ToInt</span> a <span class="ot">=&gt;</span> <span class="dt">ToInt</span> (<span class="dt">Succ</span> a) <span class="kw">where</span>
    toInt (<span class="ot">_ ::</span> <span class="dt">Proxy</span> (<span class="dt">Succ</span> a)) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> toInt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a)</code></pre></div>
<p>In order to make this piece of code work we’ll need <code>FlexibleInstances</code>, <code>UndecidableInstances</code> and <code>ScopedTypeVariables</code>. <code>FlexibleInstances</code> is a harmless extension (meaning nothing’s gonna hurt you), <code>ScopedTypeVariables</code> makes GHC understand that the <code>a</code> type variable we use in the <code>Proxy (Succ a)</code> is the same variable we are refering to later with <code>Proxy a</code>. <code>UndecidableInstances</code> could make type checking your code undecidable, but we are safe for now.</p>
<h2 id="increasing-type-family"><code>Increasing</code> type-family</h2>
<p>Taking advantage of the fact that the list type constructor is promoted by <code>DataKinds</code> to a kind constructor we can define the following type family:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Increasing</span> (<span class="ot">nats ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span>
  <span class="dt">Increasing</span> <span class="ch">'[] = True</span>
  <span class="dt">Increasing</span> <span class="ch">'[a] = True</span>
  <span class="dt">Increasing</span> (a<span class="fu">:</span>(b<span class="fu">:</span>others)) <span class="fu">=</span> (a <span class="fu">&lt;=</span> b) <span class="fu">&amp;&amp;</span> <span class="dt">Increasing</span> (b<span class="fu">:</span>others)
  <span class="dt">Increasing</span> _ <span class="fu">=</span> <span class="dt">False</span></code></pre></div>
<p>That given a type-level list of type-level nats evaluates to the type <code>True</code> if the <code>nats</code> are monotonically increasing.</p>
<h2 id="get-list-of-increasing-integers">Get list of increasing integers</h2>
<p>In the same vein we obtained an integer for every type-level nat, we now want to get a list of integers for every type-level list of types of kind <code>Nat</code>, but, we’ll only do so for monotonically increasing lists.</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> (<span class="dt">Increasing</span> nats <span class="fu">~</span> <span class="dt">True</span>) <span class="ot">=&gt;</span> <span class="dt">ToIncreasing</span> (<span class="ot">nats ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span>
<span class="ot">  toIncreasing ::</span> <span class="dt">Proxy</span> nats <span class="ot">-&gt;</span> [<span class="dt">Int</span>]

<span class="kw">instance</span> <span class="dt">ToIncreasing</span> <span class="ch">'[] where</span>
  toIncreasing _ <span class="fu">=</span> []

instances (<span class="dt">ToInt</span> a, <span class="dt">ToIncreasing</span> others, <span class="dt">Increasing</span> (a<span class="fu">:</span>others) <span class="fu">~</span> <span class="dt">True</span>) <span class="ot">=&gt;</span> <span class="dt">ToIncreasing</span> (a<span class="fu">:</span>others) <span class="kw">where</span>
    toIncreasing (<span class="ot">_ ::</span> <span class="dt">Proxy</span> (a<span class="fu">:</span>others)) <span class="fu">=</span>
        toInt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a) <span class="fu">:</span> toIncreasing (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> others)

toIncreasing (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="ch">'[Zero, One, Two]) -- [0,1,2]</span>
toIncreasing (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="ch">'[Two, Zero, One]) -- compile-time error</span></code></pre></div>
<h2 id="observations">Observations</h2>
<ol style="list-style-type: decimal">
<li><p>Interestingly enough we need more constraints in the last instance definition that would be <em>provably</em> needed. We know that every <code>a</code> is a <code>Nat</code> and that every <code>Nat</code> is a <code>ToInt</code> but we have to have that as a constraint anyway. Moreover, if <code>Increasing (a:others) ~ True</code> then necessarily <code>ToIncreasing others</code> is satisfied, but once again we need it as a constraint.</p></li>
<li><p>This approach can be easily extended to other invariants that can be defined inductively on lists. How much more extendable is this technique?</p></li>
<li><p>Nobody wants to define lists of numbers like <code>[ThreehundredThirtyTwo, Fifteen]</code> and that’s ok. <a href="https://downloads.haskell.org/~ghc/7.10.1/docs/html/users_guide/type-level-literals.html">Type-literals</a> would allow us to provide an ergonomic API.</p></li>
<li><p>Some potentially useful type-level combinators arise from this code. There probably are libraries of type-level combinators out there. Have to take a look.</p></li>
<li><p><a href="http://ponies.io/posts/2014-07-30-typelits.html">This post</a> talks about some of the things I talk in here too and was quite didactic.</p></li>
</ol>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
