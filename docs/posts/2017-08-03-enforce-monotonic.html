<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>Type Level Memes - Enforce lists to be monotonic at compile time</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">Type Level Memes</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Enforce lists to be monotonic at compile time</h1>

            <div class="info">
    Posted on August  3, 2017
    
</div>

<p>In this post we’ll se how we can use haskell’s type system to enforce certain invariants at compile time. The particular example we’ll elaborate will consist of enforcing that fixed constant lists are increasingly monotonic, but I suspect this very same approach could be naturally extended to much more general settings. Future posts may treat the reach of this technique.</p>
<p>For making this happen, we are going to need various language extensions, These extensions will be introduced as needed along some resources I’ve found useful for learning about them.</p>
<h2 id="type-level-nats">Type-level Nats</h2>
<p>It’s no surprise that if we want to have the type-checker enforce a numeric property (of course we don’t actually need any numbers for monotony to make sense, but we’ll use numbers here for the sake of simplicity).</p>
<p>We know the usual peano naturals can be encoded as a type in haskell:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span>

<span class="co">-- Then we can have values as</span>
<span class="ot">one ::</span> <span class="dt">Nat</span>
one <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Z</span>

<span class="ot">two ::</span> <span class="dt">Nat</span>
two <span class="fu">=</span> <span class="dt">Succ</span> one</code></pre></div>
<p>But using the <code>DataKinds</code> language extension we can promote the type <code>Nat</code>, <code>Z</code> to a type with kind <code>Nat</code> and <code>Succ</code> to a type constructor that takes one <code>Nat</code> and returns another <code>Nat</code>.</p>
<p>So using DataKinds we can do the following thing:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Nat</span> <span class="fu">=</span> <span class="dt">Z</span> <span class="fu">|</span> <span class="dt">Succ</span> <span class="dt">Nat</span>

<span class="kw">type</span> <span class="dt">One</span> <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">Z</span>
<span class="kw">type</span> <span class="dt">Two</span> <span class="fu">=</span> <span class="dt">Succ</span> <span class="dt">One</span></code></pre></div>
<p>And now <code>One</code> and <code>Two</code> are types of kind <code>Nat</code>. Note that with DataKinds, <code>Nat</code> is both a type (of kind <code>*</code>) and a kind at the same time (but as separate things, and actually, if there is ambiguity as to what you are referring two, be it the type or the kind, GHC will understand that you mean <code>Nat</code> the type unless you precede it with a quote as in <code>'Nat</code>). Following this logic, we can have both <code>one</code> and <code>two</code> as values of type <code>Nat</code> and <code>One</code> and <code>Two</code> as types of kind <code>Nat</code>.</p>
<p>As a beginner, I was used to haskell types having values (except for <code>Void</code>, maybe) and wondered why would a type be useful without values (except, again, for the use cases of <code>Void</code>). I hope this posts answers somehow this question, because nor <code>Z</code> nor <code>One</code>, nor <code>Two</code> (considering <code>Z</code> as the type, not the type constructor) have values. Only types with kind <code>*</code> have values and as we said before the types we just defined have kind <code>Nat</code>. So there it is, we are going to use different types that have no values for something <em>useful</em>.</p>
<h2 id="checking-type-equality">Checking type equality</h2>
<p>How do we check whether two types are equal? Well we can do things like these sometimes:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Eq</span> a <span class="fu">=</span> <span class="dt">Eq</span> a a

<span class="kw">type</span> <span class="dt">A</span> <span class="fu">=</span> <span class="dt">Int</span>

a <span class="fu">=</span> <span class="dt">Eq</span> (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">A</span>) (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">Int</span>)
b <span class="fu">=</span> (<span class="dv">3</span><span class="ot"> ::</span> <span class="dt">A</span>)<span class="ot"> ::</span> <span class="dt">Int</span></code></pre></div>
<p>If the types are not equal, we’ll have errors at compile time. However, it’s easy to say we can’t always use this trick because we are relying on having a value, which may not be true as we’ve already talked about. <code>Proxy</code> is a really useful tool in this case:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Proxy</span> a <span class="fu">=</span> <span class="dt">Proxy</span> <span class="co">-- or import Data.Proxy</span></code></pre></div>
<p><code>Proxy</code> always has a value no matter what the type <code>a</code> is, and the value is really easy to construct. So we can use the previous technique with <code>Proxy</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">a <span class="fu">=</span> <span class="dt">Eq</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">One</span>) (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Two</span>) <span class="co">-- compile-time error</span>

b <span class="fu">=</span> <span class="dt">Eq</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Suc</span> (<span class="dt">Suc</span> <span class="dt">Z</span>))) (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Two</span>) <span class="co">-- everythings' cool</span></code></pre></div>
<h2 id="type-level-functions">Type-level functions</h2>
<p>We can sum values of type <code>Nat</code> using the following function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">sum<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span> <span class="ot">-&gt;</span> <span class="dt">Nat</span>
sum <span class="dt">Z</span> n <span class="fu">=</span> n
sum (<span class="dt">Succ</span> n) m <span class="fu">=</span> <span class="dt">Succ</span> (sum n m)</code></pre></div>
<p>Can we <em>promote</em> this notion of a function adding values of type <code>Nat</code> to a function adding types of kind <code>Nat</code>? Turns out we can do so using the <code>TypeFamilies</code> language extension. With it, we can write the following code:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">Sum</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) (<span class="ot">b ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Nat</span> <span class="kw">where</span>
    <span class="dt">Sum</span> <span class="dt">Z</span> a <span class="fu">=</span> a
    <span class="dt">Sum</span> (<span class="dt">Succ</span> a) b <span class="fu">=</span> <span class="dt">Succ</span> (<span class="dt">Sum</span> a b)</code></pre></div>
<p>which is surprisingly similar to the value level function. Checking <code>Add One One == Two</code> can be done with the <code>Proxy</code> trick:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="dt">Eq</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">Add</span> <span class="dt">One</span> <span class="dt">One</span>)) (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">Two</span>)</code></pre></div>
<p>We can have a notion of typelevel predicates the same way we have value level predicates. As <code>DataKinds</code> does not only promote the types we write but all the <em>suitable</em> types and <code>Bool</code> is one of those <em>suitable</em> types, we have a <code>Bool</code> kind which only contains two types <code>True</code>, and <code>False</code>. That means we can have type-level predicates:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> family <span class="dt">IsZero</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span>
  <span class="dt">IsZero</span> <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">IsZero</span> _ <span class="fu">=</span> <span class="dt">False</span>


a <span class="fu">=</span> <span class="dt">Eq</span> (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> (<span class="dt">IsZero</span> <span class="dt">Two</span>)) (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> <span class="dt">True</span>) <span class="co">-- type error</span></code></pre></div>
<p>We can now define the type-level version of <code>&lt;=</code>:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> familiy <span class="dt">LessThan</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) (<span class="ot">b ::</span> <span class="dt">Nat</span>)<span class="ot"> ::</span> <span class="dt">Bool</span> <span class="kw">where</span>
  <span class="dt">LessThan</span> <span class="dt">Z</span> b <span class="fu">=</span> <span class="dt">True</span>
  <span class="dt">LessThan</span> a <span class="dt">Z</span> <span class="fu">=</span> <span class="dt">False</span>
  <span class="dt">LessThan</span> (<span class="dt">Succ</span> n) (<span class="dt">Succ</span> m) <span class="fu">=</span> <span class="dt">LessThan</span> n m</code></pre></div>
<p>More code</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">class</span> <span class="dt">ToInt</span> (<span class="ot">a ::</span> <span class="dt">Nat</span>) <span class="kw">where</span>
<span class="ot">    toInt ::</span> <span class="dt">Proxy</span> a <span class="ot">-&gt;</span> <span class="dt">Int</span>

<span class="kw">instance</span> <span class="dt">ToInt</span> <span class="dt">Z</span> <span class="kw">where</span>
    toInt _ <span class="fu">=</span> <span class="dv">0</span>

<span class="kw">instance</span> <span class="dt">ToInt</span> a <span class="ot">=&gt;</span> <span class="dt">ToInt</span> (<span class="dt">Succ</span> a) <span class="kw">where</span>
    toInt (<span class="ot">_ ::</span> <span class="dt">Proxy</span> (<span class="dt">Succ</span> a)) <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> toInt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a)

<span class="kw">type</span> family <span class="dt">Increasing</span> (<span class="ot">nats ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span>
  <span class="dt">Increasing</span> <span class="ch">'[] = True</span>
  <span class="dt">Increasing</span> <span class="ch">'[a] = True</span>
  <span class="dt">Increasing</span> (a<span class="fu">:</span>(b<span class="fu">:</span>others)) <span class="fu">=</span> (a <span class="fu">&lt;=</span> b) <span class="fu">&amp;&amp;</span> <span class="dt">Increasing</span> (b<span class="fu">:</span>others)
  <span class="dt">Increasing</span> _ <span class="fu">=</span> <span class="dt">False</span>

<span class="kw">type</span> <span class="dt">If</span> <span class="kw">type</span> <span class="fu">=</span> (<span class="kw">type</span> <span class="fu">~</span> <span class="dt">True</span>)

<span class="kw">class</span> <span class="dt">If</span> (<span class="dt">Increasing</span> nats) <span class="ot">=&gt;</span> <span class="dt">ToIncreasing</span> (<span class="ot">nats ::</span> [<span class="dt">Nat</span>]) <span class="kw">where</span>
<span class="ot">    doIt ::</span> <span class="dt">Proxy</span> nats <span class="ot">-&gt;</span> [<span class="dt">Int</span>]

<span class="kw">instance</span> <span class="dt">ToIncreasing</span> <span class="ch">'[] where</span>
    doIt _ <span class="fu">=</span> []

<span class="kw">instance</span> (<span class="dt">ToInt</span> a, <span class="dt">ToIncreasing</span> others, <span class="dt">If</span> (<span class="dt">Increasing</span> (a<span class="fu">:</span>others)) <span class="ot">=&gt;</span> <span class="dt">ToIncreasing</span> (a<span class="fu">:</span>others) <span class="kw">where</span>
  doIt (<span class="ot">_ ::</span> <span class="dt">Proxy</span> (a<span class="fu">:</span>others)) <span class="fu">=</span> toInt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> a) <span class="fu">:</span> doIt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> others)


doIt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> [<span class="dt">One</span>, <span class="dt">Two</span>]) <span class="co">-- = [1, 2]</span>
doIt (<span class="dt">Proxy</span><span class="ot"> ::</span> <span class="dt">Proxy</span> [<span class="dt">Two</span>, <span class="dt">One</span>]) <span class="co">-- compile-time error</span></code></pre></div>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
